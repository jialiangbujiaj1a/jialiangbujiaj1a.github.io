# 缓存和Redis

## 缓存

**缓存：指数据交换的缓冲区，目的即是提升程序的读写性能。**

### 缓存算法

- LRU（最近最少使用)：新添加的数据放在头部 ，被访问到的数据放在头部，超过最大缓存量的数据将被移除。
- LFU（最不经常使用)
- FIFO（先进先出)

### 缓存常见问题

**1、缓存穿透：**指查询一个一定**不存在**的数据。

​		缓存是不命中时被动写（当从缓存中查不到数据时，然后从数据库查询到该数据，写入该数据到缓存中。），如果从 DB 查不到数据则不写入缓存。

​		**解决：**方案一，缓存空对象。当从DB查询出的数据为空，将这个空结果进行缓存并设置较短的过期时间，一般不超过五分钟。

​					方案二，布隆过滤器，即查询缓存前先根据 KEY 查询【BloomFilter 缓存】。如果不存在对应的值，直接返回；如果存在，继续向下执行。

**2、缓存雪崩**：指缓存由于某些原因无法提供服务( 例如，缓存挂掉了 )，所有请求全部达到 DB 中，导致 DB 负荷大增，最终挂掉的情况。

​	**解决：**方案一，缓存高可用（搭建集群）

​				方案二，使用本地缓存（设置较短的过期时间，保证实时性）

**3、缓存击穿：**指某个**极度“热点”**数据在某个时间点过期时，恰好在这个时间点对这个 KEY 有大量的并发请求过来，这些请求发现缓存过期一般都会从 DB 加载数据并回设到缓存。

- 和缓存“雪崩“”的区别在于，前者针对某一 KEY 缓存，后者则是很多 KEY 。
- 和缓存“穿透“”的区别在于，这个 KEY 是真实存在对应的值的。

​		**解决：**方案一，加锁，请求发现缓存不存在后，去查询 DB 前，使用分布式锁，保证有且只有一个线程去查询 DB ，并更新到缓存。

**4、缓存和 DB 的一致性如何保证**

**场景**

并发的场景下，导致读取老的 DB 数据，更新到缓存中。

缓存和 DB 的操作，不在一个事务中，可能只有一个 DB 操作成功，而另一个 Cache 操作失败，导致不一致。

**解决**

1、将缓存可能存在的并行写，实现串行写。

> 注意，这里指的是缓存的并行写。在被动读中，如果缓存不存在，也存在写。

- 2、实现数据的最终一致性。

1）先淘汰缓存，再写数据库

因为先淘汰缓存，所以数据的最终一致性是可以得到有效的保证的。先淘汰缓存，即使写数据库发生异常，也就是下次缓存读取时，多读取一次数据库。

但是，这种方案会存在缓存和 DB 的数据会不一致的情况，那么，我们需要解决缓存并行写，实现串行写。比较简单的方式，引入分布式锁。

- 在写请求时，先淘汰缓存之前，先获取该分布式锁。
- 在读请求时，发现缓存不存在时，先获取分布式锁。

2）先写数据库，再更新缓存

按照“先写数据库，再更新缓存”，我们要保证 DB 和缓存的操作，能够在“同一个事务”中，从而实现最终一致性。

**基于定时任务来实现**

- 首先，写入数据库。
- 然后，在写入数据库所在的事务中，插入一条记录到任务表。该记录会存储需要更新的缓存 KEY 和 VALUE 。
- 【异步】最后，定时任务每秒扫描任务表，更新到缓存中，之后删除该记录。



## Redis

**介绍：**是一个基于内存的高性能Key-Value数据库。

### Redis的线程模型

Redis 内部使用文件事件处理器 `file event handler`，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 Socket，根据 Socket 上的事件来选择对应的事件处理器进行处理。

文件事件处理器的结构包含 4 个部分：

- 多个 Socket 。
- IO 多路复用程序。
- 文件事件分派器。
- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）。

多个 Socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理

### 为什么 Redis 单线程模型也能效率这么高

- 1、C 语言实现。
- 2、纯内存操作。
- 3、基于非阻塞的 IO 多路复用机制。
- 4、单线程，避免了多线程的频繁上下文切换问题。

### 持久化方式

**方式一：** RDB【全量】持久化，是指在指定的时间间隔内将内存中的**数据集快照**写入磁盘。实际操作过程是，fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件。

**方式二：**AOF【增量】持久化，以日志的形式记录服务器所处理的每一个**写、删除操作**，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。

**选择：**不要仅仅使用RDB那样会丢失数据，也不要仅仅使用AOF，没有RDB恢复速度来的快，RDB简单粗暴，健壮

### 过期策略

1. **惰性删除** ：只会在取出key的时候才对数据进行过期检查。这样对CPU最友好，但是可能会造成太多过期 key 没有被删除。
2. **定期删除** ： 每隔一段时间抽取一批 key 执行删除过期key操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。

定期删除对内存更加友好，惰性删除对CPU更加友好。Redis 采用的是 **定期删除+惰性/懒汉式删除** 。

### 内存淘汰机制

**allkeys-lru（least recently used）**：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）

Redis 内存数据集大小上升到一定 maxmemory 的时候，就会进行数据淘汰策略。

### Redis 有哪些数据结构

如果你是 Redis 普通玩家，可能你的回答是如下五种数据结构：

- 字符串 String
- 字典Hash
- 列表List
- 集合Set
- 有序集合 SortedSet

如果你是 Redis 中级玩家，还需要加上下面几种数据结构：

- HyperLogLog
- Geo
- Bitmap

如果你是 Redis 高端玩家，你可能玩过 Redis Module ，可以再加上下面几种数据结构：

- BloomFilter
- RedisSearch
- Redis-ML
- JSON