---
title: Java并发
tags: Java并发
sidebar:
  nav: docs-zh
---

# Java并发

## 进程与线程

### 1、线程、进程、程序

**进程**是程序的实例，是程序（浏览器）的一次执行实例，进程可以分为一到多个线程。

线程作为最小调度单位，进程作为资源分配的最小单位。

### 2、并发、并行

并发（concurrent）是同一时间应对多件事情的能力

并行（parallel）是同一时间动手做多件事情的能力

**单核 cpu 下，多线程不能实际提高程序运行效率，线程实际还是串行执行的，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu**

## Java线程

### 1、创建线程的四种方式

1）继承Thread类创建线程（定义Thread类子类，重写run()方法，调用start()方法启动线程）

2）实现Runnable接口创建线程（定义Runnable接口实现类，重写run()方法，将该类实例作为target创建Thread对象，调用start()方法启动线程）

3）使用Callable和Future创建线程（创建Callable接口实现类，实现call()方法，使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值，使用FutureTask对象作为Thread对象的target创建并启动线程（因为FutureTask实现了Runnable接口），调用FutureTask对象的get()方法来获得子线程执行结束后的返回值）

Callable接口提供了一个call（）方法作为线程执行体，call()方法可以有返回值，可以声明抛出异常，Java5提供了Future接口来代表Callable接口里call()方法的返回值，并且为Future接口提供了一个实现类FutureTask，这个实现类既实现了Future接口，还实现了Runnable接口，因此可以作为Thread类的target。

4）使用线程池例如用Executor框架

### 2、常见方法

#### Thread类

**start()** 让线程进入就绪状态，当得到CPU时间片时才会运行

**run()** 线程启动后调用的方法（直接调用不会创建线程执行，Runnable方式创建，线程启动后调用Runnable的run()方法，继承Thread则是调用覆盖的run()方法）

**join()** 当前线程里调用其它线程t的join方法，当前线程进入WAITING/TIMED_WAITING状态，当前线程不会释放已经持有的对象锁

**isInterrupted()** 判断是否被打断，不会清除打断标记

**interrupt()** 打断线程（如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并清除打断标记 ；如果打断的正在运行的线程，则会设置打断标记 ；park 的线程被打断，也会设置 打断标记）

**interrupted()** （static）判断当前线程是否被打断会清除打断标记

**sleep(long n)** 线程进入阻塞状态，不释放锁资源（static）让当前执行的线程休眠n毫秒，并让出cpu的时间片给其它线程

**yield()** 线程进入就绪状态，不释放锁资源（static）提示线程调度器让出当前线程对CPU的使用

**stop()** 停止线程运行 比较暴力，已过时

#### Object类

**wait()** 当前线程释放对象锁，进入等待队列 使用是需要对象锁，而LockSupport.park()不需要

**notify()** 唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象监视器上等待的所有线程。

### 守护线程

为用户线程服务，只要非守护线程运行结束，即使守护线程没有执行完，也会强制结束。

可以通过Thread.setDaemon(true)设置线程为守护线程（在start()方法之前）

### 线程状态


**初始状态NEW** 实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来

**就绪状态（运行中状态）** 调用start()方法进入就绪状态，获得CPU时间片进入运行中状态，用完时间片、调用当前线程yield()或获取到锁的线程进入就绪状态

**阻塞状态** 线程阻塞在进入synchronized或者lock时的状态

**等待状态** 此状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒

**超时等待状态** 处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。

**终止状态** 当线程的run()方法完成时，或者主线程的main()方法完成时，就认为它终止

## Synchronized

### 1、介绍

Synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。加锁解锁由JVM实现。

### 2、用法

> 用于普通同步方法，锁是当前实例对象

> 用于静态同步方法，锁是当前类的class对象

> 用于同步方法块，锁是括号里面的对象

### 3、原理

**Java对象头** synchronized用的锁存在对象头中，对象头包含Mark Word（标记字段，用于存储对象自身运行时数据）、Klass Pointer（类型指针，对象指向它的类元数据指针）

**Monitor监视器** 每个对象头都可以关联一个Monitor对象，当用Synchronized给对象上锁后，对象头的 MarkWord 中的LockWord指向Monitor的起始地址

**流程** 刚开始 Monitor中Owner为null，当第一个线程执行synchronized(obj)就会将Monitor的所有者Owner置为自己，Monitor中只能有一个 Owner，如果其它线程也来执行 synchronized(obj)，就会进入阻塞队列 BLOCKED，当第一个线程执行完同步代码块的内容，然后唤醒阻塞队列中等待的线程来竞争锁，竞争的时是非公平的

**实现**

- 同步代码块是使用 monitorenter 和 monitorexit 指令实现的；

- 同步方法（在这看不出来需要看JVM底层实现）依靠的是方法修饰符上的ACC_SYNCHRONIZED 实现。

### 4、轻量级锁

不存在多线程竞争（多线程加锁时间错开），减少重量级锁的性能消耗

**流程** 每个线程都的栈帧都会包含一个锁记录（Lock Record）的结构，内部可以存储锁定对象的Mark Word，加锁时让锁记录中 Object reference指向锁对象，并尝试用cas替换对象的 Mark Word，将Mark Word的值存入锁记录，如果cas替换成功，对象头中存储了锁记录地址和状态00 ，表示由该线程给对象加锁；若cas失败，一种情况是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程；另一种情况是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数，当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一；当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头成功，则解锁成功，失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程

### 5、锁膨胀

尝试加轻量级锁的过程中，CAS（线程锁记录交换对象的Mark word） 操作无法成功，可能有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。

**流程** 当对象已经加了轻量级锁，此时在有线程加轻量级锁时会失败，接下来为对象申请Monitor锁，锁对象指向Monitor锁地址，当前线程进入阻塞队列阻塞，当进入同步块的线程解锁时，使用cas交换锁记录中的Mark word给对象头，此时失败，会按照对象头中Monitor地址找到Monitor设置owner为null，唤醒阻塞队列中线程

### 6、自旋锁

让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。自旋（执行一段无意义的循环）。

**适应自旋锁** 若对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋

### 7、偏向锁

轻量级锁在没有竞争时（只有一个线程获取锁），每次重入仍然需要执行 CAS 操作。

Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后只需检查 ThreadID 是否是自己，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有。

**撤销**

- 调用对象 hashCode （偏向锁的对象 MarkWord 中存储的是线程 id

- 其它线程使用对象（当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁）

- 调用 wait/notify

**批量重偏向** 如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程

**批量撤销** 当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的


### 8、总结

（同一线程下）轻量级锁是线程的锁记录与锁对象的Mark word交换（每次都是），偏向锁是第一次用线程ID替换锁对象的Mark word，之后检查线程ID是否是自己

轻量级锁锁的是线程的锁记录，重量级锁锁的是Monitor对象

### 死锁/活锁

**死锁** 多个线程相互争夺对方已有的资源，造成的相互等待

**活锁** 两个线程互相改变对方的结束条件，导致都无法结束



### wait/notify

进入同步块的线程调用wait()方法变为waiting状态，此时线程阻塞，释放锁，直到Monitor的owner线程调用notify()/notifyAll()唤醒，进入阻塞队列竞争

## volatile

**作用** 保证可见性，避免指令重排

**原理** 底层实现原理是内存屏障，对 volatile 变量的写指令后会加入写屏障，读指令前会加入读屏障

**内存屏障** 屏障下面的代码不能跟屏障上面的代码交换执行顺序。在有内存屏障的地方，线程修改完共享变量以后会马上把该变量从本地内存写回到主内存，并且让其他线程本地内存中该变量副本失效

## AQS

抽象队列同步器，是阻塞式锁和同步器工具的框架

**特点**

- 用volatile修饰的state属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁。 getState - 获取 state 状态，setState - 设置 state 状态，compareAndSetState - cas 机制设置 state 状态，独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源

- 提供了基于 FIFO 的等待队列，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护一个等待状态 waitStatus

- 条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet

## ReentrantLock

可重入锁，默认非公平

### 加锁流程

- 当没有竞争时，CAS修改state=1，设置当前线程为独占线程；

- 此时再有一个线程竞争时，cas尝试修改state由0到1，失败，构造等待队列节点，最终队列中第一个节点为哨兵节点，不关联线程，且waitStatus=-1，下一个节点关联当前等待线程，waitStatus=0

### 解锁流程

- 获取锁成功的流程释放锁，设置独占线程为null，设置state=0；

- 若等待队列不为null，并且head的waitStatus=-1,找到队列中head的下一个node，unPark()，若该node关联线程加锁成功，CAS修改state=1，设置当前线程为独占线程，头结点指向该线程关联节点，清空该节点关联线程，之前头结点从链表断开，可以垃圾回收

- 若获取锁成功的流程释放锁后又来一个线程参与竞争，且竞争成功，会将新线程设置为独占线程，node节点关联的线程重新park()阻塞

### 可重入原理

- 若当前线程已经获取到锁，再次获取锁，则发生了锁重入，对state自增即可

- 解锁时对state自减，只有减为0，锁才释放成功

### 公平锁原理

相比非公平锁，公平锁在获取同步状态时会检查阻塞队列中是否有阻塞的线程，即自己不是首个等待获取同步状态的节点

### 条件变量

每个条件变量对应一个等待队列

**await流程** 当前持有锁的线程调用await，创建新的Node状态为-2，关联当前线程，加入等待队列尾部

**signal流程** 持有锁线程唤醒等待队列线程，即将等待队列中Node加入AQS队列尾部，将waitStatus改为0，将上一个节点waitStatus改为-1

## ReadWriteLock

读写锁支持多个读操作并发执行，写操作只能由一个线程来操作。内部使用同一个state和队列，读锁占用state的高16位，写锁占用低16位。

## Semaphore/Countdownlatch/CycliBarrier

**Semaphore** 信号量，控制某一资源同时访问的线程数

**Countdownlatch** 初始化标记次数，await可使当前线程阻塞，调用countDown使标记次数减1，当标记次数为0时，唤醒阻塞的线程。适合在主线程需要等待子线程执行完毕后在执行或者需要等待某些资源的时候。

**CyclicBarrier** 循环栅栏，初始化时标记线程数，每个线程执行到某个需要同步的时刻调用await()等待，当启动的线程数达到标记线程数，则并发执行。适合需要线程相互等待对方完成时，比如多线程计算，在对计算结果进行汇总。

## 阻塞队列

阻塞队列是一个支持两个附加操作的队列

- 队列为空时，获取队列元素的线程会等待队列变为非空

- 队列已满时，存储元素的线程会等待队列可用

**场景** Socket客户端数据的读取和解析，读取数据的线程不断的将数据放入队列，解析数据的线程不断的从队列取数据解析




