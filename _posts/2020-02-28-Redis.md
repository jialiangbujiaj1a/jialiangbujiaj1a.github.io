---
title: Redis
tags: Redis
sidebar:
  nav: docs-zh
---

### Redis有哪些数据类型

#### String

常用命令: set,get,decr,incr,mget 等

String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用

#### Hash

常用命令： hget,hset,hgetall 等。

hash 是一个 string 类型的 field 和 value 的映射表，这个是类似map的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在redis里，然后每次读写缓存的时候，可以就操作hash里的某个字段。

```
key=150
value={
  “id”: 150,
  “name”: “zhangsan”,
  “age”: 20
}
```

#### List

常用命令: lpush,rpush,lpop,rpop,lrange等

可以存储一些有序列表数据，比如微博的关注列表，粉丝列表，

#### Set

常用命令： sadd,spop,smembers,sunion 等

set 无序集合，自动去重，当然也可以基于jvm内存里的HashSet进行去重，但是如果某个系统部署在多台机器上，得基于redis进行全局的set去重

#### Sorted Set

常用命令： zadd,zrange,zrem,zcard等

排序的set，去重但是可以排序，写进去的时候给一个分数，自动根据分数排序。例如排行榜：将每个用户以及其对应的什么分数写入进去，zadd board score username，接着zrevrange board 0 99，就可以获取排名前100的用户；zrank board username，可以看到用户在排行榜里的排名

### Redis的单线程模型

redis有一个文件事件处理器，包含多个socket，IO多路复用程序，文件时间分派器，事件处理器(命令请求处理器，命令回复处理器，连接应答处理器)

客户端请求redis的server socket请求建立连接，当然也存在多个客户端同时请求，并发产生不同的操作，每个操作对应不同的文件事件，IO多路复用程序会监听多个socket，放在同一个队列中进行排队，每次从队列中取出一个socket给事件分派器，事件分派器把socket给对应的事件处理器，当事件处理完之后，IO多路复用程序才会将队列中的下一个socket给事件分派器。文件事件分派器会根据每个socket当前产生的事件，来选择对应的事件处理器来处理。

![redis单线程模型](https://jialiangbujiaj1a.github.io/imgs/redis/redis单线程模型.png)

### Redis单线程为什么有很高的效率

1、核心是非阻塞的IO多路复用机制，负责监听轮询所有socket，之后放入一个队列中

2、纯内存操作(事件分派器和时间处理器操作)

3、单线程避免了多线程频繁上下文切换问题

### Redis过期策略和内存淘汰机制

#### 过期策略

当存入的数据到过期时间时采用定期删除+惰性删除对key删除。

所谓定期删除就是Redis每隔100ms就随机抽取一些设置了过期时间的key，检查是否过期，过期则删除(注意：redis并不会遍历所有设置过期时间的key)；定期删除会导致很多过期数据没有删掉，惰性删除：在获取某个key时，redis会检查是否过期，如果过期则删除。

#### 内存淘汰机制

1、allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）

2、noeviction：当内存不足以容纳新写入数据时，新写入操作会报错

3、allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key

4、volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key

5、volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key

6、volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除