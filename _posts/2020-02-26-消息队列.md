---
title: 消息队列
tags: 消息队列 MQ
sidebar:
  nav: docs-zh
---

### 为什么使用消息队列，消息队列都有哪些场景

#### 消息队列的使用场景主要有三个，即解耦、异步和削峰
解耦：

原始场景：A系统发送个数据到BCD三个系统，接口调用发送，那如果E系统也要这个数据呢？那如果C系统现在不需要了呢？现在A系统又要发送第二种数据了呢？A系统负责人濒临崩溃中。。。

使用MQ解耦后：系统A产生一条数据，发送到MQ中去，B、C、D系统需要这个数据就去MQ消费即可，此时新增系统E也需要A的数据，则也直接去MQ中消费；假如系统C不需要数据就取消对MQ消息的消费即可，系统A不需要考虑给谁发送数据，不需要考虑其他系统是否调用成功、失败超时等问题。

异步：

原始场景：A系统接收一个请求，需要在自己本地写库，还需要在BCD三个系统写库，自己本地写库要20ms，BCD三个系统分别写库要300ms、450ms、200ms。最终请求总延时是20 + 300 + 450 + 200 = 970ms，接近1s，用户体验极差。

使用MQ异步后：A系统接收请求，本系统写库花费20ms，之后发送三条消息到三个消息队列，花费5ms，系统BCD去自己对应的队列去消费消息，分别写库要300ms、450ms、200ms。对于用户而言响应时间是20+5=25ms。

削峰：

原始场景：每天0点到11点，A系统风平浪静，每秒并发请求数量就100个。结果每次一到12点~1点，每秒并发请求数量突然会暴增到5000条。但是系统最大的处理能力就只能是每秒钟处理2000个请求。

使用MQ削峰后：高峰期每秒的5000请求写入队列，系统A最多每秒处理2000请求，则每秒从队列中拉取2000请求，此时会导致大量请求积压在队列中，这个积压随着高峰期过去，系统A会消费掉。

#### 消息队列的缺点

由于引入的外部依赖增多导致系统可用性降低；使系统复杂性增高，需要考虑消息是否被重复消费，消息丢失的情况；还存在一致性的问题

### ActiveMQ、RabbitMQ、RocketMQ、Kafka对比

#### ActiveMQ

非常成熟，功能强大，在业内大量的公司以及项目中都有应用

偶尔会有较低概率丢失消息

而且现在社区以及国内应用都越来越少，官方社区现在对ActiveMQ 5.x维护越来越少，几个月才发布一个版本

而且确实主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用

#### RabbitMQ

erlang语言开发，性能极其好，延时很低；

吞吐量到万级，MQ功能比较完备

而且开源提供的管理界面非常棒，用起来很好用

社区相对比较活跃，几乎每个月都发布几个版本分

但是问题也是显而易见的，RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。

而且erlang开发，如果对这个东西的掌控很弱，基本职能依赖于开源社区的快速维护和修复bug。

而且rabbitmq集群动态扩展会很麻烦，其实主要是erlang语言本身带来的问题。很难读源码，很难定制和掌控。

#### RocketMQ

接口简单易用，在阿里大规模应用过

日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是ok的，还可以支撑大规模的topic数量，支持复杂MQ业务场景

接口这块不是按照标准JMS规范走的有些系统要迁移需要修改大量代码

#### Kafka

仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展

同时kafka最好是支撑较少的topic数量即可，保证其超高吞吐量

kafka唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略

这个特性天然适合大数据实时计算以及日志收集