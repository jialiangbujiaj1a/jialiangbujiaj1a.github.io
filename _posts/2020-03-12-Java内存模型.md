---
title: Java内存模型
tags: Java内存模型
sidebar:
  nav: docs-zh
---

### 内存模型

> Java内存模型的主要目标是定义程序中变量的访问规则。即在虚拟机中将变量存储到主内存或者将变量从主内存取出这样的底层细节



Java 内存模型对主内存与工作内存之间的具体交互协议定义了八种操作：

lock(锁定):作用于主内存的变量，一个变量在同一时间只能一个线程锁定，该操作表示这条线成独占这个变量

unlock(解锁):作用于主内存的变量，表示这个变量的状态由处于锁定状态被释放，这样其他线程才能对该变量进行锁定

read(读取):作用于主内存变量，表示把一个主内存变量的值传输到线程的工作内存，以便随后的load操作使用

load(载入):作用于线程的工作内存的变量，表示把read操作从主内存中读取的变量的值放到工作内存的变量副本中(副本是相对于主内存的变量而言的)

use(使用):作用于线程的工作内存中的变量，表示把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行该操作

assign(赋值):作用于线程的工作内存的变量，表示把执行引擎返回的结果赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时就会执行该操作

store(存储):作用于线程的工作内存中的变量，把工作内存中的一个变量的值传递给主内存，以便随后的write操作使用

write(写入):作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中

注意：

不允许read和load、store和write操作之一单独出现；不允许一个线程丢弃最近的assign操作；不允许一个线程回写没有修改的变量到主内存；变量只能在主内存中产生；一个变量在同一时刻只能被一个线程对其进行lock操作；对变量执行lock操作，就会清空工作空间该变量的值；不允许对没有lock的变量执行unlock操作；对一个变量执行unlock之前，必须先把变量同步回主内存中。

![内存模型](https://jialiangbujiaj1a.github.io/imgs/java内存模型/内存模型.jpg)



### volatile

关键字volatile可以说是java虚拟机中提供的最轻量级的同步机制.

volatile类型的变量保证对所有线程的可见性：volatile类型的变量每次值被修改了就立即同步回主内存，每次使用时就需要从主内存重新读取值。

volatile类型的变量禁止指令重排序优化：在本地代码中插入许多内存屏障指令来禁止指令重排序，保证处理器不发生代码乱序执行行为。

**原子性(Automicity)**

即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

**可见性**

可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

正如前面所说，volatile类型的变量在修改后会立即同步给主内存，在使用的时候会从主内存重新读取，是依赖主内存为中介来保证多线程下变量对其他线程的可见性的。
除了volatile，synchronized和final也可以实现可见性。synchronized关键字是通过unlock之前必须把变量同步回主内存来实现的，final则是在初始化后就不会更改，所以只要在初始化过程中没有把this指针传递出去也能保证对其他线程的可见性。

**有序性**

即程序执行的顺序按照代码的先后顺序执行。


**volatile原理**

加入volatile关键字时，会多出一个lock前缀指令。lock前缀指令其实就相当于一个内存屏障。内存屏障是一组处理指令，用来实现对内存操作的顺序限制。

volatile 变量进行写操作时，JVM 会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。Lock 前缀指令确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。

**总结**

> volatile可见性；对一个volatile的读，总可以看到对这个变量最终的写；

> volatile原子性；volatile对单个读/写具有原子性（32位Long、Double），但是复合操作除外，例如i++;

> JVM底层采用“内存屏障”来实现volatile语义

[内存模型](https://www.jianshu.com/p/15106e9c4bf3)


### happen-before原则

**概念**

保证了程序的“有序性”，它规定如果两个操作的执行顺序不存在于happens-before原则中，那么他们就不能保证有序性，可以随意进行重排序

**原则**

程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；

锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；

volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；

传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；

线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；

线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；

线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；

对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；

### 重排序

在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：

> 在单线程环境下不能改变程序运行的结果；

> 存在数据依赖关系的不允许重排序

上述两点可以归结于一点：无法通过happens-before原则推导出来的，JMM允许任意的排序。